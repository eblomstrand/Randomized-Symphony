# Author: Emily Blomstrand
# Program: asm5.s
# Assignment: asm5
# Purpose: This program creates a randomely generated musical piece that uses various MIPS syscalls 
# to create an atonal experience for the listener that follows the same basic structure, but will be 
# different every time. I had a lot of fun and laughs while making this project.

# Notes: Please be aware that the 30 second limit for each function is not necessarily a guarantee on the time
# the piece will play for, but more of a limit on how many notes can be played.
# Note on playback: There will be times where it sounds like nothing is playing, but this is because some instruments 
# at certain frequencies will be almost impossible to hear with standard audio equipment. I decided to leave this feature in 
# since it adds to the unpredictability of the piece, as well as creates an ominous mood. Plus it makes the entrance of the 
# next note even funnier.
.data 
	message: .ascii "Hello, welcome to your own personal COVID-19 Symphony. This music is a representation that I believe"
		 .ascii "\nfits the time in which we are living, as all of us try to hold onto our last brian cells. What\n"
		 .asciiz "you are about to hear is randomely generated by the computer, so be prepared. Enjoy."
.text
# This function uses the mips random int with bounds syscall, 42, to randomely generate an integer
# between 0 and 127, which is placed in $v0. This function will be used for pitch and instrument 
# selection for the midi calls.
.globl random_127
random_127:
#NOTE: The random number will be in $a0 after the function is called by the caller
	#PROLOGUE
	addiu $sp, $sp, -24 	# allocate stack space -- default of 24 here
	sw $fp, 0($sp) 		# save callers frame pointer
	sw $ra, 4($sp) 		# save return address
	addiu $fp, $sp, 20 	# setup frame pointer
	
	li $v0, 42		#random number range sycall 
	li $a1, 127		# upper bound for the random number(i.e. number will be random between 0-127)
	syscall 
	
	#EPILOGUE
	lw $ra, 4($sp) 		# get return address from stack
	lw $fp, 0($sp) 		# restore the callers frame pointer
	addiu $sp, $sp, 24 	# restore the callers stack pointer
	jr $ra
	
# This function does everything random_127 does, with the added functionality of 
# bounding the volume between 53 and 80 so that the volume of the piece is an acceptable level 
# to playback at, but still preserves the nuance of different dynamics. 
.globl random_vol
random_vol:
#selects a random volume between 53 and 80 (mezo piano to forte)
	#PROLOGUE
	addiu $sp, $sp, -24 	# allocate stack space -- default of 24 here
	sw $fp, 0($sp) 		# save callers frame pointer
	sw $ra, 4($sp) 		# save return address
	addiu $fp, $sp, 20 	# setup frame pointer
	
	li   $v0, 42		# random number range sycall 
	li   $a1, 27		# upper bound for the random number(i.e. number will be random between 0-27, adding 53 after)
	addi $a0, $a0, 53 	# $a0 += 53 final num is between 53 and 80
	syscall 
	
	#EPILOGUE
	lw $ra, 4($sp) 		# get return address from stack
	lw $fp, 0($sp) 		# restore the callers frame pointer
	addiu $sp, $sp, 24 	# restore the callers stack pointer
	jr $ra

# This function plays a "solo", where an instrument is randomely selected by the program and
# then until 30 seconds worth of tones have been played, a random pitch, duration, and volume is 
# selected for the instrument to play. This function uses the 33 syscall, because I want the solo 
# instrument to only be "playing" one note at a time.	
.globl solo
solo:
	#PROLOGUE
	addiu $sp, $sp, -24	# allocate stack space -- default of 24 here
	sw $fp, 0($sp) 		# save callers frame pointer
	sw $ra, 4($sp) 		# save return address
	addiu $fp, $sp, 20 	# setup frame pointer
	
	#REGISTERS:
	# $s0 = first instrument
	# $t0 = volume, where 64 is a nice mezo forte
	# $t1 = pitch number
	# $t2 = millisecond duration 
	# $t3 = milliseconds remaining (3 minutes at beginning)
	# $t8 = 180000 (3 minutes)
	
	addiu $sp, $sp, -4	# saving $s0
	sw    $s0, 0($sp)	
	
	jal random_127
	add $s0, $a0, $zero     # $s0 = instrument number
	addi $t3, $t3, 30000	# $t3 = 30000 - $t2 (30 seconds minus duration) = milliLeft
		
	SOLO_LOOP:
		slt $t9, $t3, $zero		# $t9 = milliLeft < 0
		bne $t9, $zero, AFTER_SOLO 	# if !(milliLeft < 0), then:
		
		jal random_127
		add $t1, $a0, $zero		# $t0 = pitch 
		jal random_vol
		add $t0, $a0, $zero 		# $t0 = volume 
		jal random_mill
		add $t2, $a0, $zero		# $t2 = milliseconds
	
		sub  $t3, $t3, $t2		# $t3 = milliLeft -$t2
		
		li   $v0, 33			# midi syscall
		add  $a0, $t1, $zero 		# $a0 = pitch
		add  $a1, $t2, $zero		# $a1 = duration in milliseconds
		add  $a2, $s0, $zero 		# $a2 = instrument 
		add  $a3, $t0, $zero 		# $a3 = volume
		syscall
		j SOLO_LOOP
	
	AFTER_SOLO:
	
	li   $v0, 33		# midi syscall
	add  $a0, $t1, $zero 	# $a0 = pitch
	add  $a1, $t2, $zero	# $a1 = duration in milliseconds
	add  $a2, $s0, $zero 	# $a2 = instrument 
	add  $a3, $t0, $zero 	# $a3 = volume
	syscall
	
	lw    $s0, 0($sp)	# restoring $s0
	addiu $sp, $sp, 4
	
	#EPILOGUE
	lw $ra, 4($sp) 		# get return address from stack
	lw $fp, 0($sp) 		# restore the callers frame pointer
	addiu $sp, $sp, 24 	# restore the callers stack pointer
	jr $ra
	
# This function creates a "combo" instrument section for the piece by exploiting how the computer processes
# the midi syscall 31. The computer processes the syscalls fast enough to where multiple tones play at once if you don't wait using 32 until 
# the tone is finished playing, creating a cool ensemble feel to the section. It is important to note that the 
# 30 second limit is merely an upper bound and not a guarantee of how long this section will play for. 
.globl combo
combo:
	#PROLOGUE
	addiu $sp, $sp, -24	# allocate stack space -- default of 24 here
	sw $fp, 0($sp)		# save callers frame pointer
	sw $ra, 4($sp) 		# save return address
	addiu $fp, $sp, 20 	# setup frame pointer
	
	addiu $sp, $sp, -4	# saving $s0
	sw    $s0, 0($sp)
	
	#REGISTERS:
	# $s0 = first instrument
	# $t0 = volume, where 64 is a nice mezo forte
	# $t1 = pitch number
	# $t2 = millisecond duration 
	# $t3 = milliseconds remaining (30 seconds at beginning), but note that the syscall 31 has the pitches play as soon as ready
	# $t8 = 180000 (3 minutes)
	
	addi $t3, $t3, 30000	# $t3 = 30000 - $t2 (30 seconds minus duration) = milliLeft
	
	COMBO_LOOP:
		slt $t9, $t3, $zero		# $t9 = milliLeft < 0
		bne $t9, $zero, AFTER_COMBO 	# if !(milliLeft < 0), then:
		
		jal random_127
		add $s0, $a0, $zero    		# $s0 = instrument number
		jal random_127
		add $t1, $a0, $zero		# $t0 = pitch 
		jal random_vol
		add $t0, $a0, $zero 		# $t0 = volume 
		jal random_mill
		add $t2, $a0, $zero		# $t2 = milliseconds
		sub  $t3, $t3, $t2		# $t3 = milliLeft -$t2
		
		li   $v0, 31			# midi syscall
		add  $a0, $t1, $zero 		# $a0 = pitch
		add  $a1, $t2, $zero		# $a1 = duration in milliseconds
		add  $a2, $s0, $zero 		# $a2 = instrument 
		add  $a3, $t0, $zero 		# $a3 = volume
		syscall
		j COMBO_LOOP
	
	AFTER_COMBO:
	lw    $s0, 0($sp)	#restoring $s0
	addiu $sp, $sp, 4
	
	#EPILOGUE
	lw $ra, 4($sp) 		# get return address from stack
	lw $fp, 0($sp) 		# restore the callers frame pointer
	addiu $sp, $sp, 24 	# restore the callers stack pointer
	jr $ra
	
# This function essentially does the same thing as the solo, except it sets two instruments instead of one and 
# then trades off on them playing, which is intended to mimic how many classical pieces are organized in terms of
# duets. The syscall 33 is used to create this effect since we want each instrument to wait for each other. 
.globl duet
duet:
	#PROLOGUE
	addiu $sp, $sp, -24 	# allocate stack space -- default of 24 here
	sw $fp, 0($sp) 		# save callers frame pointer
	sw $ra, 4($sp) 		# save return address
	addiu $fp, $sp, 20 	# setup frame pointer
	
	#REGISTERS:
	# $s0 = first instrument
	# $t0 = volume, where 64 is a nice mezo forte
	# $t1 = pitch number
	# $t2 = millisecond duration 
	# $t3 = milliseconds remaining (30 seconds at beginning)
	# $t8 = 180000 (3 minutes)
	addiu $sp, $sp, -8
	sw    $s0, 0($sp)	# saving $s0 and $s1
	sw    $s1, 4($sp)
	
	jal random_127
	add $s0, $a0, $zero    # $s0 = instrument number 1
	jal random_127
	add $s1, $a0, $zero    # $s1 = instrument number 2
	
	addi $t3, $t3, 30000	# $t3 = 30000 - $t2 (30 seconds minus duration) = milliLeft
	
	DUET_LOOP:
		slt $t9, $t3, $zero		# $t9 = milliLeft < 0
		bne $t9, $zero, AFTER_DUET 	# if !(milliLeft < 0), then:
		
		jal random_127
		add $t1, $a0, $zero	# $t0 = pitch 
		jal random_vol
		add $t0, $a0, $zero 	# $t0 = volume 
		jal random_mill
		add $t2, $a0, $zero	# $t2 = milliseconds
		
		li   $v0, 33		# midi syscall
		add  $a0, $t1, $zero 	# $a0 = pitch
		add  $a1, $t2, $zero	# $a1 = duration in milliseconds
		add  $a2, $s0, $zero 	# $a2 = instrument 
		add  $a3, $t0, $zero 	# $a3 = volume
		
		jal random_127
		add $t1, $a0, $zero	# $t0 = pitch 
		jal random_vol
		add $t0, $a0, $zero 	# $t0 = volume 
		jal random_mill
		add $t2, $a0, $zero	# $t2 = milliseconds
		sub  $t3, $t3, $t2	# $t3 = milliLeft -$t2
		
		li   $v0, 33		# midi syscall
		add  $a0, $t1, $zero 	# $a0 = pitch
		add  $a1, $t2, $zero	# $a1 = duration in milliseconds
		add  $a2, $s1, $zero 	# $a2 = instrument 
		add  $a3, $t0, $zero 	# $a3 = volume
	
		syscall
		j DUET_LOOP
	
	AFTER_DUET:
	sw    $s0, 0($sp) 	# restoring $s0 and $s1
	sw    $s1, 4($sp)
	addiu $sp, $sp, 8
	
	#EPILOGUE
	lw $ra, 4($sp) 		# get return address from stack
	lw $fp, 0($sp) 		# restore the callers frame pointer
	addiu $sp, $sp, 24 	# restore the callers stack pointer
	jr $ra

# This funtion plays a finale, in which an instrument plays at once for an upper bound of 5 seconds to 
# add a sense of closure to the piece. Because of the combo section played before the finale, a decrescendo 
# effect is created as multiple instruments drop out and the single final instrument is left playing the 5 second note.
# This functio is essentially a simplified version of the solo functon without a loop.
.globl finale
finale:
	#PROLOGUE
	addiu $sp, $sp, -24 	# allocate stack space -- default of 24 here
	sw $fp, 0($sp)	 	# save callers frame pointer
	sw $ra, 4($sp) 		# save return address
	addiu $fp, $sp, 20 	# setup frame pointer
	
	addiu $sp, $sp, -4	#saving $s0 onto stack 
	sw    $s0, 0($sp)

	jal random_127
	add $s0, $a0, $zero     # $s0 = instrument number
	jal random_127
	add $t1, $a0, $zero	# $t0 = pitch 
	jal random_vol
	add  $t0, $a0, $zero 	# $t0 = volume 
	addi $t2, $zero, 5000	# $t2 = milliseconds = 5000 = 5 seconds
	sub  $t3, $t3, $t2	# $t3 = milliLeft -$t2
		
	li   $v0, 33		# midi syscall
	add  $a0, $t1, $zero 	# $a0 = pitch
	add  $a1, $t2, $zero	# $a1 = duration in milliseconds
	add  $a2, $s0, $zero 	# $a2 = instrument 
	add  $a3, $t0, $zero 	# $a3 = volume
	
	sw    $s0, 0($sp)	#restoring $s0
	addiu $sp, $sp, 4
	
	#EPILOGUE
	lw $ra, 4($sp) 		# get return address from stack
	lw $fp, 0($sp) 		# restore the callers frame pointer
	addiu $sp, $sp, 24 	# restore the callers stack pointer
	jr $ra

# This function uses the random int with range syscall of MIPS to randomely 
# generate a millisecond note duration between 0.5 seconds and 5 seconds, which 
# will be used for all note duration inputs for the midi syscalls. 
.globl random_mill
random_mill:
	#PROLOGUE
	addiu $sp, $sp, -24 	# allocate stack space -- default of 24 here
	sw $fp, 0($sp) 		# save callers frame pointer
	sw $ra, 4($sp) 		# save return address
	addiu $fp, $sp, 20 	# setup frame pointer

	li   $v0, 42		# random number range sycall 
	li   $a1, 4500		# upper bound for the random number(i.e. number will be random between 0-4500, adding 500 after)
	addi $a0, $a0, 500 	# final num is between 500 and 5000 milliseconds (0.5 - 5 seconds)
	syscall 

	#EPILOGUE
	lw $ra, 4($sp) 		# get return address from stack
	lw $fp, 0($sp) 		# restore the callers frame pointer
	addiu $sp, $sp, 24 	# restore the callers stack pointer
	jr $ra

# This is the main function for the piece. When the program is run, a message is 
# outputted to the console for the user's benefit, and the piece begins. 
.globl main
main:
	#PROLOGUE
	addiu $sp, $sp, -24 	# allocate stack space -- default of 24 here
	sw $fp, 0($sp) 		# save callers frame pointer
	sw $ra, 4($sp) 		# save return address
	addiu $fp, $sp, 20 	# setup frame pointer
	
	#displays message
	li $v0, 4
	la $a0, message
	syscall
		
	jal combo	# plays multiple instruments together (movement 1)
	jal solo	# a single instrument plays (movement 2)
	jal combo	# multiple again (movement 3)
	jal duet	# two instruments play together (movement 4)
	jal combo	# multiple (movement 5)
	jal finale	# movement 6, unison ending to the piece
	
	#EPILOGUE
	lw $ra, 4($sp) 		# get return address from stack
	lw $fp, 0($sp) 		# restore the callers frame pointer
	addiu $sp, $sp, 24 	# restore the callers stack pointer
	
